# -*- coding: utf-8 -*-
"""Housing Valuation Tool - ML Multivariable Regression

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CGXzIYAWUtQut6mshbC-K4r95Ty20P60

## Housing prices valuator

Let's make a predictor for housing prices!
"""

from sklearn.linear_model import LinearRegression
from sklearn.datasets import load_boston
from sklearn.metrics import mean_squared_error

import numpy as np
import pandas as pd

# Loading dataset
boston_dataset= load_boston()

# Creating pandas dataframe
boston_df = pd.DataFrame(data=boston_dataset.data, columns=boston_dataset.feature_names)

# Features Selection
# Removing unecessary variables given our previous analysis
features = boston_df.drop(['INDUS', 'AGE'], axis=1)
# print(features.shape) # (506, 11)

# Target Preparation
prices_log = np.log(boston_dataset.target)
target = pd.DataFrame(data=prices_log, columns=['PRICE'])

#target.shape #(506, 1) --> all set in the same dimension!

# Prepare one array with unseen data to be predicted 

# 1st method >> You can go iteratively

#property_stats = np.ndarray(shape=(1, 11)) # Empty array with the same amount of columns from features

# Index preparation - Otherwise we will not remember what which column means!
#CRIME_IDX = 0
#ZN_IDX = 1
CHAS_IDX = 2
RM_IDX = 4
PTRATIO_IDX = 8

# Initializing values - Let's make assumptions now
#property_stats[0][CRIME_IDX] = features['CRIM'].mean()
#property_stats[0][ZN_IDX] = features['ZN'].mean()
#property_stats[0][CHAS_IDX] = features['CHAS'].mean()
property_stats[0][RM_IDX] = features['RM'].mean() # We will use to predict
property_stats[0][PTRATIO_IDX] = features['PTRATIO'].mean() # We will use to predict

# Or make everything quickly!
property_stats = features.mean().values.reshape(1, 11)

property_stats

# Set up our model - Multivariable Regression
regressor = LinearRegression().fit(features, target)

# Save our predictions
fitted_values = regressor.predict(features)

# MSE - Mean Squared Error
MSE = mean_squared_error(target, fitted_values) # 0.0351608...

# RMSE - Root Mean Squared Error
RMSE = np.sqrt(MSE) # 0.1875121...

# Returns a estimative given all parameters
def get_log_estimative(nr_rooms, # Mandatory - User Input
                       students_per_classroom, # Mandatory - User Input
                       next_to_river= False, # Optional parameter - User Input
                       high_confidence= True): # Optional parameter - for Range Calculation
                        

  # Setting up properties (variables) by default all of them are the mean from our dataset
  property_stats[0][RM_IDX] = nr_rooms
  property_stats[0][PTRATIO_IDX] = students_per_classroom

  # Optional value treatmean
  if next_to_river:
    
    property_stats[0][CHAS_IDX] = 1

  # Make Prediction
  # Important Note: We are just picking from user good parameters (our user will not know the amount of Nitric Acid on the soil right?). The other ones we are using the average from our dataset!
  log_estimate = regressor.predict(property_stats)[0][0] # remove the 2-D array returning the value purely

  # Calculate Pricing Range
  if high_confidence: # 2 s. d. - 95% confidence

    upper_bound = log_estimate + 2*RMSE
    lower_bound = log_estimate - 2*RMSE
    interval = 95

  else: # 1 s. d. = 68% confidence

    upper_bound = log_estimate + RMSE
    lower_bound = log_estimate - RMSE
    interval = 68

  return log_estimate, upper_bound, lower_bound, interval

# Testing our predict function
get_log_estimative(3, 20, next_to_river= True)

np.median(boston_dataset.target) # Median value from our dataset

# Step 1: Create a scaling prices factor for inflation correction

CURRENT_MEDIAN_PRICE = 583.3 # Boston median housing prices from zillow.com
SCALE_FACTOR = CURRENT_MEDIAN_PRICE / np.median(boston_dataset.target)


def get_dollar_estimate(rm, ptratio, chas=False, high_conf=True):

  # Docstring --> Will tell to other users what this function does
  """
  Estimate the price of a property in Boston - USA

  Keyword arguments:
  rm -- number of rooms in the property
  ptratio -- number of students per teacher in the classrom for the school in the area
  chas -- True if the property is next to the river, false otherwise
  high_conf -- True for a 95% prediction interval, false for 68% 

  """

  # Preventing unrealistic values
  if rm < 1 or ptratio < 1:
    print('Unrealistic value! try again')
    return 

  # Step 2: Make some prediction
  log_estimate, upper_bound, lower_bound, confidence_score = get_log_estimative(nr_rooms= rm, 
                                                                                students_per_classroom= ptratio, 
                                                                                next_to_river= chas, 
                                                                                high_confidence= high_conf) 

  # Step 3: Convert for today's USD - Ok, it is for easy understanding we can make it shorter of course...
  usd_current_estimative = np.e**log_estimate * 1000 * SCALE_FACTOR
  usd_current_highBoundValue = np.e**upper_bound * 1000 * SCALE_FACTOR
  usd_current_lowBoundValue = np.e**lower_bound * 1000 * SCALE_FACTOR

  usd_current_estimative_rounded = np.around(usd_current_estimative, -3)
  usd_current_highBoundValue_rounded = np.around(usd_current_highBoundValue, -3)
  usd_current_lowBoundValue_rounded = np.around(usd_current_lowBoundValue, -3)

  print(f'Estimated property value is {usd_current_estimative_rounded} USD')
  print(f'At {confidence_score}% confidence_score')
  print(f'High Price {usd_current_highBoundValue_rounded} USD')
  print(f'Lower Price {usd_current_lowBoundValue_rounded} USD')

get_dollar_estimate(rm=2, ptratio= 20, chas=True)